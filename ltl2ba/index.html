<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (ltl2ba.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – ltl2ba</nav><header class="odoc-preamble"><h1 id="ltl2ba-documentation"><a href="#ltl2ba-documentation" class="anchor"></a>ltl2ba documentation</h1></header><nav class="odoc-toc"><ul><li><a href="#the-context">The context</a></li><li><a href="#list-of-modules">List of modules</a></li><li><a href="#algo">The algorithm</a><ul><li><a href="#the-first-phase">The first phase</a></li><li><a href="#the-second-phase">The second phase</a><ul><li><a href="#reduce">Reduced subset</a></li><li><a href="#transitions">Transitions</a></li><li><a href="#genbuch">Generalized Büchi automata on transitions</a></li><li><a href="#summary">Summary</a></li></ul></li></ul></li></ul></nav><div class="odoc-content"><h2 id="the-context"><a href="#the-context" class="anchor"></a>The context</h2><p>This program has been implemented during the course <i>Introduction à la vérification</i> of the University of Bordeaux.</p><p>The goal is to implement <a href="#algo">The algorithm</a> used to translate a LTL formula into an equivalent <a href="#genbuch">Generalized Büchi automata on transitions</a>.</p><h2 id="list-of-modules"><a href="#list-of-modules" class="anchor"></a>List of modules</h2><ul><li><a href="parser.html"><code>Parser</code></a> - The LTL parser</li><li><a href="Ltl/index.html"><code>Ltl</code></a> - The LTL formul</li></ul><h2 id="algo"><a href="#algo" class="anchor"></a>The algorithm</h2><p><i>This algorithm is taken from the course <em>Introduction à la vérification</em> written by <a href="https://www.labri.fr/profil/Zeitoun_ID1120210651">Marc Zeitoun</a>.</i></p><p>Let φ be an LTL formula.</p><h3 id="the-first-phase"><a href="#the-first-phase" class="anchor"></a>The first phase</h3><p>The first phase consists in putting φ in <i>negation normal form</i> (NNF), where:</p><ul><li>all negation appear only in front of the atomic propositions,</li><li>only other logical operators <code>∧</code>, and <code>∨</code> can appear, and</li><li>only the temporal operator <code>X</code>, <code>U</code>, and <code>R</code> can appear.</li></ul><p>To calculate <i>nnf(φ)</i>, following rules can be applied recursively -- see <a href="Ltl/index.html#val-nnf"><code>Ltl.nnf</code></a>:</p><ul><li>nnf(ρ) = ρ</li><li>nnf(¬¬φ) = nnf(φ)</li><li>nnf(¬(φ ∨ ψ)) = nnf(¬φ) ∧ nnf(¬ψ)</li><li>nnf(¬(φ ∧ ψ)) = nnf(¬φ) ∨ nnf(¬ψ)</li><li>nnf(¬Xφ) = X nnf(¬φ)</li><li>nnf(¬(φ U ψ)) = nnf(¬φ) R nnf(¬ψ)</li><li>nnf(¬(φ R ψ)) = nnf(¬φ) U nnf(¬ψ)</li></ul><h3 id="the-second-phase"><a href="#the-second-phase" class="anchor"></a>The second phase</h3><p>For the second phase, let reassign φ as <i>nnf(φ)</i> and define 𝒜 = (S, ⟶, S<sub>0</sub>, F<sub>1</sub>, ..., F<sub>k</sub>) as the equivalent Büchi automata of φ. An automata state s ∈ S is a subset of sub-formulas of φ and the initial state S<sub>0</sub> is {φ}.</p><h4 id="reduce"><a href="#reduce" class="anchor"></a>Reduced subset</h4><p>A subset Z of formulas in NNF is <b>reduced</b> if:</p><ul><li>formulas of Z are of the form: p, ¬q, or Xα,</li><li>⊥ ∉ Z, and ∀.p ∈ AP, {p, ¬p} ⊈ Z.</li></ul><h4 id="transitions"><a href="#transitions" class="anchor"></a>Transitions</h4><p>In order to define transitions from a state Y, an oriented graph is build from Y. Let Y = Z ∪ {α} where α is not a <a href="#reduce">Reduced subset</a> and is <b>maximal</b> in Y (i.e. α is not a sub-formula of any other such formula of Y). Edges from Y are:</p><ul><li>If α = α<sub>1</sub> ∨ α<sub>2</sub>, Y ⟶ Z ∪ {α<sub>1</sub>} and Y ⟶ Z ∪ {α<sub>2</sub>}.</li><li>If α = α<sub>1</sub> ∧ α<sub>2</sub>, Y ⟶ Z ∪ {α<sub>1</sub>, α<sub>2</sub>}.</li><li>If α = α<sub>1</sub> R α<sub>2</sub>, Y ⟶ Z ∪ {α<sub>1</sub>, α<sub>2</sub>} and Y ⟶ Z ∪ {Xα, α<sub>2</sub>}.</li><li>If α = α<sub>1</sub> U α<sub>2</sub>, Y ⟶ Z ∪ {α<sub>2</sub>} and Y ⟶<sup>α</sup> Z ∪ {Xα, α<sub>1</sub>}.</li></ul><p>The symbol ⟶<sup>α</sup> means the edge is <b>marked</b> by α.</p><p>Then, is defined:</p><ul><li>Red(Y) = {Z reduced | Y ⟶<sup>*</sup> Z}</li><li>Red<sub>α</sub>(Y) = {Z reduced | Y ⟶<sup>*</sup> without using an edge marked by α}</li></ul><p>When all formulas in Z are reduced, is defined:</p><ul><li>next(Z) = {α | Xα ∈ Z}</li><li>Σ<sub>Z</sub> the intersection of all p and ¬p in Z.</li></ul><p>Finally, transitions from Y are: {Y ⟶<sup>Σ<sub>Z</sub></sup> next(Z) | Z ⊆ Red(Y)}. Is added an <b>acceptance condition</b> for each sub-formula α wich is an Until: F<sub>α</sub> = {Y ⟶<sup>Σ<sub>Z</sub></sup> next(Z) | Y ⊆ Q and Z ⊆ Red<sub>α</sub>(Y)}.</p><h4 id="genbuch"><a href="#genbuch" class="anchor"></a>Generalized Büchi automata on transitions</h4><p>At the end the automata built, is a generalized Büchi automata <i>on transitions</i>: it's similar to generalized Büchi automata except that <b>acceptance conditions are set of transitions</b> instead of set of states. A <b>run</b> from the initial state is accepted, if for each acceptance conditions, it goes infinitely often through a transition of this condition.</p><h4 id="summary"><a href="#summary" class="anchor"></a>Summary</h4><p>The automata 𝒜 = (S, ⟶, S<sub>0</sub>, F<sub>1</sub>, ..., F<sub>k</sub>) equivalent to the formula φ, is defined with:</p><ul><li>Initial state: S<sub>0</sub> = {φ}</li><li>Transitions from a state Y: {Y ⟶<sup>Σ<sub>Z</sub></sup> next(Z) | Z ⊆ Red(Y)}</li><li>Acceptance conditions: ∀.α ∈ φ, with α = α<sub>1</sub> U α<sub>2</sub>: F<sub>α</sub> = {Y ⟶<sup>Σ<sub>Z</sub></sup> next(Z) | Y ⊆ Q and Z ⊆ Red<sub>α</sub>(Y)}</li></ul></div></body></html>