<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (ltl2ba.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – ltl2ba</nav><header class="odoc-preamble"><h1 id="ltl2ba-documentation"><a href="#ltl2ba-documentation" class="anchor"></a>ltl2ba documentation</h1></header><nav class="odoc-toc"><ul><li><a href="#the-context">The context</a></li><li><a href="#list-of-modules">List of modules</a></li><li><a href="#algo">The algorithm</a><ul><li><a href="#the-first-phase">The first phase</a><ul><li><a href="#the-negation-normal-form">The negation normal form</a></li></ul></li><li><a href="#second">The second phase</a><ul><li><a href="#reduce">Reduced subset</a></li><li><a href="#transitions">Transitions</a></li><li><a href="#genbuch">Generalized Büchi automata on transitions</a></li></ul></li><li><a href="#summary">Summary</a></li><li><a href="#question">Question</a></li><li><a href="#examples">Examples</a><ul><li><a href="#1.-φ-=-p-u-xq">1. φ = p U Xq</a></li><li><a href="#2.-ψ-=-g(p-⇒-xfq)">2. ψ = G(p ⇒ XFq)</a></li></ul></li></ul></li></ul></nav><div class="odoc-content"><h2 id="the-context"><a href="#the-context" class="anchor"></a>The context</h2><p>This program has been implemented during the course <i>Introduction à la vérification</i> of the University of Bordeaux.</p><p>The goal is to implement <a href="#algo">The algorithm</a> used to translate a LTL formula into an equivalent <a href="#genbuch">Generalized Büchi automata on transitions</a>.</p><h2 id="list-of-modules"><a href="#list-of-modules" class="anchor"></a>List of modules</h2><ul><li><a href="parser.html"><code>Parser</code></a> - The LTL parser</li><li><a href="Ltl/index.html"><code>Ltl</code></a> - The LTL formul</li></ul><h2 id="algo"><a href="#algo" class="anchor"></a>The algorithm</h2><p><i>This algorithm is taken from the course <em>Introduction à la vérification</em> written by <a href="https://www.labri.fr/profil/Zeitoun_ID1120210651">Marc Zeitoun</a>.</i></p><p>Let φ be an LTL formula.</p><h3 id="the-first-phase"><a href="#the-first-phase" class="anchor"></a>The first phase</h3><p>The first phase consists in putting φ in <i>negation normal form</i> (NNF), where:</p><ul><li>all negation appear only in front of the atomic propositions,</li><li>only other logical operators <code>∧</code>, and <code>∨</code> can appear, and</li><li>only the temporal operator <code>X</code>, <code>U</code>, and <code>R</code> can appear.</li></ul><h4 id="the-negation-normal-form"><a href="#the-negation-normal-form" class="anchor"></a>The negation normal form</h4><p>To calculate <i>nnf(φ)</i>, following rules can be applied recursively -- see <a href="Ltl/index.html#val-nnf"><code>Ltl.nnf</code></a>:</p><ul><li>nnf(ρ) = ρ</li><li>nnf(¬¬φ) = nnf(φ)</li><li>nnf(¬(φ ∨ ψ)) = nnf(¬φ) ∧ nnf(¬ψ)</li><li>nnf(¬(φ ∧ ψ)) = nnf(¬φ) ∨ nnf(¬ψ)</li><li>nnf(¬Xφ) = X nnf(¬φ)</li><li>nnf(¬(φ U ψ)) = nnf(¬φ) R nnf(¬ψ)</li><li>nnf(¬(φ R ψ)) = nnf(¬φ) U nnf(¬ψ)</li></ul><h3 id="second"><a href="#second" class="anchor"></a>The second phase</h3><p>For the second phase, let reassign φ as <i>nnf(φ)</i> and define 𝒜 = (S, ⟶, S<sub>0</sub>, F<sub>1</sub>, ..., F<sub>k</sub>) as the equivalent Büchi automata of φ. An automata state s ∈ S is a subset of sub-formulas of φ and the initial state S<sub>0</sub> is {φ}.</p><h4 id="reduce"><a href="#reduce" class="anchor"></a>Reduced subset</h4><p>A subset Z of formulas in NNF is <b>reduced</b> if:</p><ul><li>formulas of Z are of the form: p, ¬q, or Xα,</li><li>⊥ ∉ Z, and ∀.p ∈ AP, {p, ¬p} ⊈ Z.</li></ul><h4 id="transitions"><a href="#transitions" class="anchor"></a>Transitions</h4><p>In order to define transitions from a state Y, an oriented graph is build from Y. Let Y = Z ∪ {α} where α is not a <a href="#reduce">Reduced subset</a> and is <b>maximal</b> in Y (i.e. α is not a sub-formula of any other such formula of Y). Edges from Y are:</p><ul><li>If α = α<sub>1</sub> ∨ α<sub>2</sub>, Y ⟶ Z ∪ {α<sub>1</sub>} and Y ⟶ Z ∪ {α<sub>2</sub>}.</li><li>If α = α<sub>1</sub> ∧ α<sub>2</sub>, Y ⟶ Z ∪ {α<sub>1</sub>, α<sub>2</sub>}.</li><li>If α = α<sub>1</sub> R α<sub>2</sub>, Y ⟶ Z ∪ {α<sub>1</sub>, α<sub>2</sub>} and Y ⟶ Z ∪ {Xα, α<sub>2</sub>}.</li><li>If α = α<sub>1</sub> U α<sub>2</sub>, Y ⟶ Z ∪ {α<sub>2</sub>} and Y ⟶<sup>α</sup> Z ∪ {Xα, α<sub>1</sub>}.</li></ul><p>The symbol ⟶<sup>α</sup> means the edge is <b>marked</b> by α.</p><p>Then, is defined:</p><ul><li>Red(Y) = {Z reduced | Y ⟶<sup>*</sup> Z}</li><li>Red<sub>α</sub>(Y) = {Z reduced | Y ⟶<sup>*</sup> without using an edge marked by α}</li></ul><p>When all formulas in Z are reduced, is defined:</p><ul><li>next(Z) = {α | Xα ∈ Z}</li><li>Σ<sub>Z</sub> the intersection of all p and ¬p in Z.</li></ul><p>Finally, transitions from Y are: {Y ⟶<sup>Σ<sub>Z</sub></sup> next(Z) | Z ⊆ Red(Y)}. Is added an <b>acceptance condition</b> for each sub-formula α wich is an Until: F<sub>α</sub> = {Y ⟶<sup>Σ<sub>Z</sub></sup> next(Z) | Y ⊆ S and Z ⊆ Red<sub>α</sub>(Y)}.</p><h4 id="genbuch"><a href="#genbuch" class="anchor"></a>Generalized Büchi automata on transitions</h4><p>At the end the automata built, is a generalized Büchi automata <i>on transitions</i>: it's similar to generalized Büchi automata except that <b>acceptance conditions are set of transitions</b> instead of set of states. A <b>run</b> from the initial state is accepted, if for each acceptance conditions, it goes infinitely often through a transition of this condition.</p><h3 id="summary"><a href="#summary" class="anchor"></a>Summary</h3><p>The automata 𝒜 = (S, ⟶, S<sub>0</sub>, F<sub>1</sub>, ..., F<sub>k</sub>) equivalent to the formula φ, is defined with:</p><ul><li>Initial state: S<sub>0</sub> = {φ}</li><li>Transitions from a state Y: {Y ⟶<sup>Σ<sub>Z</sub></sup> next(Z) | Z ⊆ Red(Y)}</li><li>Acceptance conditions: ∀.α ∈ φ, with α = α<sub>1</sub> U α<sub>2</sub>: F<sub>α</sub> = {Y ⟶<sup>Σ<sub>Z</sub></sup> next(Z) | Y ⊆ S and Z ⊆ Red<sub>α</sub>(Y)}</li></ul><h3 id="question"><a href="#question" class="anchor"></a>Question</h3><p><i>Let <em>𝒜</em> be a Büchi automaton on transitions. Give a standard Büchi automaton recognizing the same language as <em>𝒜</em>, and justify its construction by proving that both automata recognize the same language. How to generalize the construction to generalized automata?</i></p><p>TODO.</p><h3 id="examples"><a href="#examples" class="anchor"></a>Examples</h3><h4 id="1.-φ-=-p-u-xq"><a href="#1.-φ-=-p-u-xq" class="anchor"></a>1. φ = p U Xq</h4><p>Let apply the <a href="#algo">The algorithm</a> to the LTL formula φ = p U Xq.</p><p>Note that φ is already in NNF, therefore we can go directly to the <a href="#second">The second phase</a>.</p><p>First, let's calculate all sub-formulas of φ: {p U Xq; Xq; p; q}.</p><p>Now, let's calculate transitions from the initial state S<sub>0</sub> = {p U Xq}.</p><p>Let's calculate the edges of the intermediate oriented graph from S<sub>0</sub>:</p><ol><li>S<sub>0</sub> ⟶ {} ∪ {α<sub>2</sub>} = {Xq}</li><li>S<sub>0</sub> ⟶ <sup>φ</sup> {} ∪ {Xα, α<sub>1</sub>} = {X(φ), p}</li></ol><p>In first edge, {Xq} is reduced, therefore the transition: {φ} ⟶<sup>Σ</sup> {q} = S<sub>0</sub> ⟶<sup>Σ</sup> {q} and the state {q} need to be added to 𝒜.</p><p>In the second one, {X(φ), p} is reduced, therefore the transition: {φ} ⟶<sup>p</sup> {φ} = S<sub>0</sub> ⟶<sup>p</sup> {φ} needs to be added to 𝒜.</p><p>Finally, Red<sub>φ</sub>(S<sub>0</sub>) = {Xq}, because it's the only reduced state reachable by a non marked edge. Therefore, the acceptance condition: F<sub>φ</sub> = {S<sub>0</sub> ⟶<sup>Σ</sup> next({Xq})} = {S<sub>0</sub> ⟶<sup>Σ</sup> {q})} needs to be added to 𝒜.</p><p>Now, let's repeat previous steps for the state {q}.</p><p>There is no edges from {q} in the intermediate oriented graph, because the only formula of the state is q and it's reduced.</p><p>At the end, 𝒜 is defined with:</p><ul><li>S = {{φ}, {q}},</li><li>Σ = {p, q}</li><li>{φ} ⟶<sup>Σ</sup>{q} and {φ} ⟶<sup>p</sup> {φ}</li><li>S<sub>0</sub> = {φ}</li><li>F<sub>φ</sub> = {{φ} ⟶<sup>Σ</sup> {q}}</li></ul><pre>      +-----+  {p, q}  +-----+
   --&gt;| {φ} |=========&gt;| {q} |
      +-----+          +-----+
       |   ^
       \---/
        {p}

   ==&gt;: acceptance condition</pre><h4 id="2.-ψ-=-g(p-⇒-xfq)"><a href="#2.-ψ-=-g(p-⇒-xfq)" class="anchor"></a>2. ψ = G(p ⇒ XFq)</h4><p>TODO</p></div></body></html>